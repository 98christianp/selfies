import faulthandler

faulthandler.enable()

import pytest
import random

import os

import pandas as pd
import selfies as selfies
from rdkit.Chem import MolFromSmiles, MolToSmiles

test_sets = [
    ('test_sets/130K_QM9.txt', 'smiles'),
    ('test_sets/51K_NonFullerene.txt', 'smiles'),
    ('test_sets/250k_ZINC.txt', 'smiles')
]  # add if desired ('22M_eMolecule.smi', 'isosmiles')


@pytest.mark.parametrize("test_path, column_name", test_sets)
def test_roundtrip_translation(test_path, column_name):
    """Tests a roundtrip SMILES -> SELFIES -> SMILES translation of the
    SMILES examples in <test_path>.
    """

    atom_dict = selfies.get_atom_dict()
    atom_dict['N'] = 6
    selfies.set_alphabet(atom_dict)

    # File IO
    test_name = os.path.basename(test_path)
    test_name = os.path.splitext(test_name)[0]

    curr_dir = os.path.dirname(__file__)
    test_path = os.path.join(curr_dir, test_path)
    error_path = os.path.join(curr_dir, f"error_sets/error_log_{test_name}.csv")

    os.makedirs(os.path.dirname(error_path), exist_ok=True)
    error_list = []
    with open(error_path, "w+") as error_log:
        error_log.write("In, Out, Canonical In, Canonical Out\n")
    error_found_flag = False

    for chunk in pd.read_csv(test_path, chunksize=10000, delimiter=' '):

        for in_smiles in chunk[column_name]:

            mol_input = MolFromSmiles(in_smiles)
            if mol_input is None:
                continue

            out_smiles = ""
            can_input = ""
            can_output = ""

            try:
                out_smiles = selfies.decoder(selfies.encoder(in_smiles))
                mol_output = MolFromSmiles(out_smiles)

                if mol_output is None:
                    raise ValueError

                can_input = MolToSmiles(mol_input)
                can_output = MolToSmiles(mol_output)

                if can_input != can_output:
                    raise ValueError

            except (Exception, ValueError):
                error_list.append((in_smiles, out_smiles,
                                   can_input, can_output))

        with open(error_path, "a") as error_log:
            for error in error_list:
                error_log.write(','.join(error) + "\n")
        error_found_flag = error_found_flag or error_list
        error_list = []

    assert not error_found_flag


def test_random_selfies_decoder():
    """Tests selfies.decoder on SELFIES that are generated by randomly stringing
    together characters from the SELFIES alphabet.
    """

    trials = 10000
    max_len = 200

    selfies.set_alphabet()
    alphabet = list(selfies.get_alphabet())

    for i in range(trials):

        # create random SELFIES and decode
        rand_len = random.randint(1, max_len)
        rand_mol = ''.join(random.choice(alphabet) for _ in range(rand_len))
        smiles = selfies.decoder(rand_mol)

        # check if SMILES is valid
        try:
            is_valid = MolFromSmiles(smiles, sanitize=True) is not None
        except Exception:
            is_valid = False

        assert is_valid, f"Invalid SMILES {smiles} decoded from {selfies}."


if __name__ == '__main__':
    pytest.main()
